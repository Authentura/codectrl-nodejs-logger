/* eslint-disable */
// @generated by protobuf-ts 2.8.1 with parameter long_type_number,eslint_disable,ts_nocheck
// @generated from protobuf file "cc_service.proto" (package "codectrl.logs_service", syntax proto3)
// tslint:disable
// @ts-nocheck
import { LogClient } from "./cc_service.js";
import type { ClientStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { LogServer } from "./cc_service.js";
import type { RequestResult } from "./cc_service.js";
import type { ServerDetails } from "./cc_service.js";
import type { Empty } from "./google/protobuf/empty.js";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { Log } from "./log.js";
import type { Connection } from "./cc_service.js";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * LogServer is the service that should only be implemented by log servers that
 * can be connected to by a CodeCtrl front-end. Language loggers should not
 * implement this service or use it as a client for that matter. Ways of
 * enforcing that only servers can receive logs iS TBD but will be worked on in
 * the future.
 *
 * @generated from protobuf service codectrl.logs_service.LogServer
 */
export interface ILogServerClient {
    /**
     * Gets the latest log from the server, generally not used but is here for
     * compatibiliy's sake in the case where a front-end cannot use a stream.
     *
     * @generated from protobuf rpc: GetLog(codectrl.logs_service.Connection) returns (codectrl.data.log.Log);
     */
    getLog(input: Connection, options?: RpcOptions): UnaryCall<Connection, Log>;
    /**
     * Gets a stream of the available logs, this should be preferred over
     * `GetLog` when possible.
     *
     * @generated from protobuf rpc: GetLogs(codectrl.logs_service.Connection) returns (stream codectrl.data.log.Log);
     */
    getLogs(input: Connection, options?: RpcOptions): ServerStreamingCall<Connection, Log>;
    /**
     * Gets the current details about the server.
     *
     * @generated from protobuf rpc: GetServerDetails(google.protobuf.Empty) returns (codectrl.logs_service.ServerDetails);
     */
    getServerDetails(input: Empty, options?: RpcOptions): UnaryCall<Empty, ServerDetails>;
    /**
     * Registers a new front-end connection to a server instance and returns the
     * `Connection` message with a `uuid`.
     *
     * @generated from protobuf rpc: RegisterClient(google.protobuf.Empty) returns (codectrl.logs_service.Connection);
     */
    registerClient(input: Empty, options?: RpcOptions): UnaryCall<Empty, Connection>;
    /**
     * Registers an already pre-existing connection to a server instance using an
     * already generated `uuid` supplied in the `Connection`. Servers should
     * verify that the supplied `uuid` is, in fact, a valid hyphenated v4 UUID.
     * Returns a boolean whether or not the registration was succesful.
     *
     * @generated from protobuf rpc: RegisterExistingClient(codectrl.logs_service.Connection) returns (codectrl.logs_service.RequestResult);
     */
    registerExistingClient(input: Connection, options?: RpcOptions): UnaryCall<Connection, RequestResult>;
}
/**
 * LogServer is the service that should only be implemented by log servers that
 * can be connected to by a CodeCtrl front-end. Language loggers should not
 * implement this service or use it as a client for that matter. Ways of
 * enforcing that only servers can receive logs iS TBD but will be worked on in
 * the future.
 *
 * @generated from protobuf service codectrl.logs_service.LogServer
 */
export class LogServerClient implements ILogServerClient, ServiceInfo {
    typeName = LogServer.typeName;
    methods = LogServer.methods;
    options = LogServer.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Gets the latest log from the server, generally not used but is here for
     * compatibiliy's sake in the case where a front-end cannot use a stream.
     *
     * @generated from protobuf rpc: GetLog(codectrl.logs_service.Connection) returns (codectrl.data.log.Log);
     */
    getLog(input: Connection, options?: RpcOptions): UnaryCall<Connection, Log> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<Connection, Log>("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a stream of the available logs, this should be preferred over
     * `GetLog` when possible.
     *
     * @generated from protobuf rpc: GetLogs(codectrl.logs_service.Connection) returns (stream codectrl.data.log.Log);
     */
    getLogs(input: Connection, options?: RpcOptions): ServerStreamingCall<Connection, Log> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<Connection, Log>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Gets the current details about the server.
     *
     * @generated from protobuf rpc: GetServerDetails(google.protobuf.Empty) returns (codectrl.logs_service.ServerDetails);
     */
    getServerDetails(input: Empty, options?: RpcOptions): UnaryCall<Empty, ServerDetails> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, ServerDetails>("unary", this._transport, method, opt, input);
    }
    /**
     * Registers a new front-end connection to a server instance and returns the
     * `Connection` message with a `uuid`.
     *
     * @generated from protobuf rpc: RegisterClient(google.protobuf.Empty) returns (codectrl.logs_service.Connection);
     */
    registerClient(input: Empty, options?: RpcOptions): UnaryCall<Empty, Connection> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, Connection>("unary", this._transport, method, opt, input);
    }
    /**
     * Registers an already pre-existing connection to a server instance using an
     * already generated `uuid` supplied in the `Connection`. Servers should
     * verify that the supplied `uuid` is, in fact, a valid hyphenated v4 UUID.
     * Returns a boolean whether or not the registration was succesful.
     *
     * @generated from protobuf rpc: RegisterExistingClient(codectrl.logs_service.Connection) returns (codectrl.logs_service.RequestResult);
     */
    registerExistingClient(input: Connection, options?: RpcOptions): UnaryCall<Connection, RequestResult> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<Connection, RequestResult>("unary", this._transport, method, opt, input);
    }
}
/**
 * LogClient is the service that needs to be implemented by log servers so they
 * can determine how the logs are stored when they are received by the server.
 * Loggers must only use this service as a client.
 *
 * @generated from protobuf service codectrl.logs_service.LogClient
 */
export interface ILogClientClient {
    /**
     * Sends a single log. Should only be used in cases where log batching is not
     * possible or not determinable.
     *
     * @generated from protobuf rpc: SendLog(codectrl.data.log.Log) returns (codectrl.logs_service.RequestResult);
     */
    sendLog(input: Log, options?: RpcOptions): UnaryCall<Log, RequestResult>;
    /**
     * Sends a stream of logs. Should generally be preferred over `SendLog` as it
     * allows for batch sending of `Log`s and _should_ be more efficient on
     * resources.
     *
     * @generated from protobuf rpc: SendLogs(stream codectrl.data.log.Log) returns (codectrl.logs_service.RequestResult);
     */
    sendLogs(options?: RpcOptions): ClientStreamingCall<Log, RequestResult>;
}
/**
 * LogClient is the service that needs to be implemented by log servers so they
 * can determine how the logs are stored when they are received by the server.
 * Loggers must only use this service as a client.
 *
 * @generated from protobuf service codectrl.logs_service.LogClient
 */
export class LogClientClient implements ILogClientClient, ServiceInfo {
    typeName = LogClient.typeName;
    methods = LogClient.methods;
    options = LogClient.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Sends a single log. Should only be used in cases where log batching is not
     * possible or not determinable.
     *
     * @generated from protobuf rpc: SendLog(codectrl.data.log.Log) returns (codectrl.logs_service.RequestResult);
     */
    sendLog(input: Log, options?: RpcOptions): UnaryCall<Log, RequestResult> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<Log, RequestResult>("unary", this._transport, method, opt, input);
    }
    /**
     * Sends a stream of logs. Should generally be preferred over `SendLog` as it
     * allows for batch sending of `Log`s and _should_ be more efficient on
     * resources.
     *
     * @generated from protobuf rpc: SendLogs(stream codectrl.data.log.Log) returns (codectrl.logs_service.RequestResult);
     */
    sendLogs(options?: RpcOptions): ClientStreamingCall<Log, RequestResult> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<Log, RequestResult>("clientStreaming", this._transport, method, opt);
    }
}
